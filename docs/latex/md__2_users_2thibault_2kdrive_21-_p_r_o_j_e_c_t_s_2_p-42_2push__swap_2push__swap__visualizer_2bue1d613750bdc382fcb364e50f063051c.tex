\chapter{limitations}
\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c}{}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c}\index{limitations@{limitations}}
\label{_top}%
 \hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md284}{}\doxysection{\texorpdfstring{Known limitations}{Known limitations}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md284}
Over time, some limitations of Catch2 emerged. Some of these are due to implementation details that cannot be easily changed, some of these are due to lack of development resources on our part, and some of these are due to plain old 3rd party bugs.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md285}{}\doxysubsection{\texorpdfstring{Implementation limits}{Implementation limits}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md285}
\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md286}{}\doxysubsubsection{\texorpdfstring{Sections nested in loops}{Sections nested in loops}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md286}
If you are using {\ttfamily SECTION}s inside loops, you have to create them with different name per loop\textquotesingle{}s iteration. The recommended way to do so is to incorporate the loop\textquotesingle{}s counter into section\textquotesingle{}s name, like so\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{TEST\_CASE(\ \textcolor{stringliteral}{"{}Looped\ section"{}}\ )\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{char}\ i\ =\ \textcolor{charliteral}{'0'};\ i\ <\ \textcolor{charliteral}{'5'};\ ++i)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ SECTION(std::string(\textcolor{stringliteral}{"{}Looped\ section\ "{}})\ +\ i)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ SUCCEED(\ \textcolor{stringliteral}{"{}Everything\ is\ OK"{}}\ );}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


or with a {\ttfamily DYNAMIC\+\_\+\+SECTION} macro (that was made for exactly this purpose)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{TEST\_CASE(\ \textcolor{stringliteral}{"{}Looped\ section"{}}\ )\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{char}\ i\ =\ \textcolor{charliteral}{'0'};\ i\ <\ \textcolor{charliteral}{'5'};\ ++i)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ DYNAMIC\_SECTION(\ \textcolor{stringliteral}{"{}Looped\ section\ "{}}\ <<\ i)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ SUCCEED(\ \textcolor{stringliteral}{"{}Everything\ is\ OK"{}}\ );}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md287}{}\doxysubsubsection{\texorpdfstring{Tests might be run again if last section fails}{Tests might be run again if last section fails}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md287}
If the last section in a test fails, it might be run again. This is because Catch2 discovers {\ttfamily SECTION}s dynamically, as they are about to run, and if the last section in test case is aborted during execution (e.\+g. via the {\ttfamily REQUIRE} family of macros), Catch2 does not know that there are no more sections in that test case and must run the test case again.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md288}{}\doxysubsubsection{\texorpdfstring{Min\+GW/\+Cyg\+Win compilation (linking) is extremely slow}{Min\+GW/\+Cyg\+Win compilation (linking) is extremely slow}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md288}
Compiling Catch2 with Min\+GW can be exceedingly slow, especially during the linking step. As far as we can tell, this is caused by deficiencies in its default linker. If you can tell Min\+GW to instead use lld, via {\ttfamily -\/fuse-\/ld=lld}, the link time should drop down to reasonable length again.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md289}{}\doxysubsection{\texorpdfstring{Features}{Features}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md289}
This section outlines some missing features, what is their status and their possible workarounds.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md290}{}\doxysubsubsection{\texorpdfstring{Thread safe assertions}{Thread safe assertions}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md290}
Catch2\textquotesingle{}s assertion macros are not thread safe. This does not mean that you cannot use threads inside Catch\textquotesingle{}s test, but that only single thread can interact with Catch\textquotesingle{}s assertions and other macros.

This means that this is ok 
\begin{DoxyCode}{0}
\DoxyCodeLine{std::vector<std::thread>\ threads;}
\DoxyCodeLine{std::atomic<int>\ cnt\{\ 0\ \};}
\DoxyCodeLine{\textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 0;\ i\ <\ 4;\ ++i)\ \{}
\DoxyCodeLine{\ \ \ \ threads.emplace\_back([\&]()\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ++cnt;\ ++cnt;\ ++cnt;\ ++cnt;}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\&\ t\ :\ threads)\ \{\ t.join();\ \}}
\DoxyCodeLine{REQUIRE(cnt\ ==\ 16);}

\end{DoxyCode}
 because only one thread passes the {\ttfamily REQUIRE} macro and this is not 
\begin{DoxyCode}{0}
\DoxyCodeLine{std::vector<std::thread>\ threads;}
\DoxyCodeLine{std::atomic<int>\ cnt\{\ 0\ \};}
\DoxyCodeLine{\textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ i\ =\ 0;\ i\ <\ 4;\ ++i)\ \{}
\DoxyCodeLine{\ \ \ \ threads.emplace\_back([\&]()\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ++cnt;\ ++cnt;\ ++cnt;\ ++cnt;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ CHECK(cnt\ ==\ 16);}
\DoxyCodeLine{\ \ \ \ \});}
\DoxyCodeLine{\}}
\DoxyCodeLine{\textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\&\ t\ :\ threads)\ \{\ t.join();\ \}}
\DoxyCodeLine{REQUIRE(cnt\ ==\ 16);}

\end{DoxyCode}


Because C++11 provides the necessary tools to do this, we are planning to remove this limitation in the future.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md291}{}\doxysubsubsection{\texorpdfstring{Process isolation in a test}{Process isolation in a test}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md291}
Catch does not support running tests in isolated (forked) processes. While this might in the future, the fact that Windows does not support forking and only allows full-\/on process creation and the desire to keep code as similar as possible across platforms, mean that this is likely to take significant development time, that is not currently available.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md292}{}\doxysubsubsection{\texorpdfstring{Running multiple tests in parallel}{Running multiple tests in parallel}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md292}
Catch\textquotesingle{}s test execution is strictly serial. If you find yourself with a test suite that takes too long to run and you want to make it parallel, there are 2 feasible solutions
\begin{DoxyItemize}
\item You can split your tests into multiple binaries and then run these binaries in parallel.
\item You can have Catch list contained test cases and then run the same test binary multiple times in parallel, passing each instance list of test cases it should run.
\end{DoxyItemize}

Both of these solutions have their problems, but should let you wring parallelism out of your test suite.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md293}{}\doxysubsection{\texorpdfstring{3rd party bugs}{3rd party bugs}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md293}
This section outlines known bugs in 3rd party components (this means compilers, standard libraries, standard runtimes).\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md294}{}\doxysubsubsection{\texorpdfstring{Visual Studio 2017 -- raw string literal in assert fails to compile}{Visual Studio 2017 -- raw string literal in assert fails to compile}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md294}
There is a known bug in Visual Studio 2017 (VC 15), that causes compilation error when preprocessor attempts to stringize a raw string literal ({\ttfamily \#} preprocessor is applied to it). This snippet is sufficient to trigger the compilation error\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ CATCH\_CONFIG\_MAIN}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}catch.hpp"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}test"{}})\ \{}
\DoxyCodeLine{\ \ \ \ CHECK(std::string(R\textcolor{stringliteral}{"{}("{}\(\backslash\))"{})\ ==\ }\textcolor{stringliteral}{"{}\(\backslash\)"{}\(\backslash\)\(\backslash\)"{}});}
\DoxyCodeLine{\}}

\end{DoxyCode}


Catch provides a workaround, it is possible to disable stringification of original expressions by defining {\ttfamily CATCH\+\_\+\+CONFIG\+\_\+\+DISABLE\+\_\+\+STRINGIFICATION}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ CATCH\_CONFIG\_FAST\_COMPILE}}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ CATCH\_CONFIG\_DISABLE\_STRINGIFICATION}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ "{}catch.hpp"{}}}
\DoxyCodeLine{}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}test"{}})\ \{}
\DoxyCodeLine{\ \ \ \ CHECK(std::string(R\textcolor{stringliteral}{"{}("{}\(\backslash\))"{})\ ==\ }\textcolor{stringliteral}{"{}\(\backslash\)"{}\(\backslash\)\(\backslash\)"{}});}
\DoxyCodeLine{\}}

\end{DoxyCode}


{\itshape Do note that this changes the output somewhat} 
\begin{DoxyCode}{0}
\DoxyCodeLine{catchwork\(\backslash\)test1.cpp(6):}
\DoxyCodeLine{PASSED:}
\DoxyCodeLine{\ \ CHECK(\ Disabled\ by\ CATCH\_CONFIG\_DISABLE\_STRINGIFICATION\ )}
\DoxyCodeLine{with\ expansion:}
\DoxyCodeLine{\ \ "{}"{}\(\backslash\)"{}\ ==\ "{}"{}\(\backslash\)"{}}

\end{DoxyCode}
\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md295}{}\doxysubsubsection{\texorpdfstring{Visual Studio 2015 -- Alignment compilation error (C2718)}{Visual Studio 2015 -- Alignment compilation error (C2718)}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md295}
VS 2015 has a known bug, where {\ttfamily declval\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} can cause compilation error if {\ttfamily T} has alignment requirements that it cannot meet.

\doxylink{class_a}{A} workaround is to explicitly specialize {\ttfamily \doxylink{struct_catch_1_1is__range}{Catch\+::is\+\_\+range}} for given type (this avoids code path that uses {\ttfamily declval\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} in a SFINAE context).\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md296}{}\doxysubsubsection{\texorpdfstring{Visual Studio 2015 -- Wrong line number reported in debug mode}{Visual Studio 2015 -- Wrong line number reported in debug mode}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md296}
VS 2015 has a known bug where {\ttfamily \+\_\+\+\_\+\+LINE\+\_\+\+\_\+} macro can be improperly expanded under certain circumstances, while compiling multi-\/file project in Debug mode.

\doxylink{class_a}{A} workaround is to compile the binary in Release mode.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md297}{}\doxysubsubsection{\texorpdfstring{Clang/\+G++ -- skipping leaf sections after an exception}{Clang/\+G++ -- skipping leaf sections after an exception}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md297}
Some versions of {\ttfamily libc++} and {\ttfamily libstdc++} (or their runtimes) have a bug with {\ttfamily std\+::uncaught\+\_\+exception()} getting stuck returning {\ttfamily true} after rethrow, even if there are no active exceptions. One such case is this snippet, which skipped the sections "{}a"{} and "{}b"{}, when compiled against {\ttfamily libcxxrt} from master 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define\ CATCH\_CONFIG\_MAIN}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include\ <catch.hpp>}}
\DoxyCodeLine{}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}a"{}})\ \{}
\DoxyCodeLine{\ \ \ \ CHECK\_THROWS(\textcolor{keywordflow}{throw}\ 3);}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}b"{}})\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{int}\ i\ =\ 0;}
\DoxyCodeLine{\ \ \ \ SECTION(\textcolor{stringliteral}{"{}a"{}})\ \{\ i\ =\ 1;\ \}}
\DoxyCodeLine{\ \ \ \ SECTION(\textcolor{stringliteral}{"{}b"{}})\ \{\ i\ =\ 2;\ \}}
\DoxyCodeLine{\ \ \ \ CHECK(i\ >\ 0);}
\DoxyCodeLine{\}}

\end{DoxyCode}


If you are seeing a problem like this, i.\+e. a weird test paths that trigger only under Clang with {\ttfamily libc++}, or only under very specific version of {\ttfamily libstdc++}, it is very likely you are seeing this. The only known workaround is to use a fixed version of your standard library.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md298}{}\doxysubsubsection{\texorpdfstring{Clang/\+G++ -- {\ttfamily Matches} string matcher always returns false}{Clang/\+G++ -- {\ttfamily Matches} string matcher always returns false}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md298}
This is a bug in {\ttfamily libstdc++-\/4.8}, where all matching methods from {\ttfamily \texorpdfstring{$<$}{<}regex\texorpdfstring{$>$}{>}} return false. Since {\ttfamily Matches} uses {\ttfamily \texorpdfstring{$<$}{<}regex\texorpdfstring{$>$}{>}} internally, if the underlying implementation does not work, it doesn\textquotesingle{}t work either.

Workaround\+: Use newer version of {\ttfamily libstdc++}.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md299}{}\doxysubsubsection{\texorpdfstring{libstdc++, {\ttfamily \+\_\+\+GLIBCXX\+\_\+\+DEBUG} macro and random ordering of tests}{libstdc++, {\ttfamily \+\_\+\+GLIBCXX\+\_\+\+DEBUG} macro and random ordering of tests}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue1d613750bdc382fcb364e50f063051c_autotoc_md299}
Running a Catch2 binary compiled against libstdc++ with {\ttfamily \+\_\+\+GLIBCXX\+\_\+\+DEBUG} macro defined with {\ttfamily -\/-\/order rand} will cause a debug check to trigger and abort the run due to self-\/assignment. \href{https://stackoverflow.com/questions/22915325/avoiding-self-assignment-in-stdshuffle/23691322}{\texttt{ This is a known bug inside libstdc++}}

Workaround\+: Don\textquotesingle{}t use {\ttfamily -\/-\/order rand} when compiling against debug-\/enabled libstdc++. 