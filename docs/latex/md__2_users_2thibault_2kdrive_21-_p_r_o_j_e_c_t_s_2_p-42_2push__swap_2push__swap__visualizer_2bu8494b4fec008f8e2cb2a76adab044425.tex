\chapter{assertions}
\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425}{}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425}\index{assertions@{assertions}}
\label{_top}%
 \hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md145}{}\doxysection{\texorpdfstring{Assertion Macros}{Assertion Macros}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md145}
{\bfseries{Contents}}~\newline
 Natural Expressions~\newline
 Exceptions~\newline
 Matcher expressions~\newline
 Thread Safety~\newline
 Expressions with commas~\newline


Most test frameworks have a large collection of assertion macros to capture all possible conditional forms ({\ttfamily \+\_\+\+EQUALS}, {\ttfamily \+\_\+\+NOTEQUALS}, {\ttfamily \+\_\+\+GREATER\+\_\+\+THAN} etc).

Catch is different. Because it decomposes natural C-\/style conditional expressions most of these forms are reduced to one or two that you will use all the time. That said there is a rich set of auxiliary macros as well. We\textquotesingle{}ll describe all of these here.

Most of these macros come in two forms\+:\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md146}{}\doxysubsection{\texorpdfstring{Natural Expressions}{Natural Expressions}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md146}
The {\ttfamily REQUIRE} family of macros tests an expression and aborts the test case if it fails. The {\ttfamily CHECK} family are equivalent but execution continues in the same test case even if the assertion fails. This is useful if you have a series of essentially orthogonal assertions and it is useful to see all the results rather than stopping at the first failure.


\begin{DoxyItemize}
\item {\bfseries{REQUIRE(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape expression} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}} and ~\newline

\item {\bfseries{CHECK(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape expression} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}}
\end{DoxyItemize}

Evaluates the expression and records the result. If an exception is thrown, it is caught, reported, and counted as a failure. These are the macros you will use most of the time.

Examples\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{CHECK(\ str\ ==\ "{}string\ value"{}\ );}
\DoxyCodeLine{CHECK(\ thisReturnsTrue()\ );}
\DoxyCodeLine{REQUIRE(\ i\ ==\ 42\ );}

\end{DoxyCode}



\begin{DoxyItemize}
\item {\bfseries{REQUIRE\+\_\+\+FALSE(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape expression} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}} and ~\newline

\item {\bfseries{CHECK\+\_\+\+FALSE(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape expression} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}}
\end{DoxyItemize}

Evaluates the expression and records the {\itshape logical NOT} of the result. If an exception is thrown it is caught, reported, and counted as a failure. (these forms exist as a workaround for the fact that ! prefixed expressions cannot be decomposed).

Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{REQUIRE\_FALSE(\ thisReturnsFalse()\ );}

\end{DoxyCode}


Do note that "{}overly complex"{} expressions cannot be decomposed and thus will not compile. This is done partly for practical reasons (to keep the underlying expression template machinery to minimum) and partly for philosophical reasons (assertions should be simple and deterministic).

Examples\+:
\begin{DoxyItemize}
\item {\ttfamily CHECK(a == 1 \&\& b == 2);} This expression is too complex because of the {\ttfamily \&\&} operator. If you want to check that 2 or more properties hold, you can either put the expression into parenthesis, which stops decomposition from working, or you need to decompose the expression into two assertions\+: {\ttfamily CHECK( a == 1 ); CHECK( b == 2);}
\item {\ttfamily CHECK( a == 2 \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} b == 1 );} This expression is too complex because of the {\ttfamily \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|}} operator. If you want to check that one of several properties hold, you can put the expression into parenthesis (unlike with {\ttfamily \&\&}, expression decomposition into several {\ttfamily CHECK}s is not possible).
\end{DoxyItemize}\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md147}{}\doxysubsubsection{\texorpdfstring{Floating point comparisons}{Floating point comparisons}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md147}
When comparing floating point numbers -\/ especially if at least one of them has been computed -\/ great care must be taken to allow for rounding errors and inexact representations.

Catch provides a way to perform tolerant comparisons of floating point values through use of a wrapper class called {\ttfamily Approx}. {\ttfamily Approx} can be used on either side of a comparison expression. It overloads the comparisons operators to take a tolerance into account. Here\textquotesingle{}s a simple example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{REQUIRE(\ performComputation()\ ==\ Approx(\ 2.1\ )\ );}

\end{DoxyCode}


Catch also provides a user-\/defined literal for {\ttfamily Approx}; {\ttfamily \+\_\+a}. It resides in the {\ttfamily Catch\+::literals} namespace and can be used like so\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using\ namespace\ }Catch::literals;}
\DoxyCodeLine{REQUIRE(\ performComputation()\ ==\ 2.1\_a\ );}

\end{DoxyCode}


{\ttfamily Approx} is constructed with defaults that should cover most simple cases. For the more complex cases, {\ttfamily Approx} provides 3 customization points\+:


\begin{DoxyItemize}
\item {\bfseries{epsilon}} -\/ epsilon serves to set the coefficient by which a result can differ from {\ttfamily Approx}\textquotesingle{}s value before it is rejected. {\itshape By default set to {\ttfamily std\+::numeric\+\_\+limits\texorpdfstring{$<$}{<}float\texorpdfstring{$>$}{>}::epsilon()\texorpdfstring{$\ast$}{*}100}.}
\item {\bfseries{margin}} -\/ margin serves to set the the absolute value by which a result can differ from {\ttfamily Approx}\textquotesingle{}s value before it is rejected. {\itshape By default set to {\ttfamily 0.\+0}.}
\item {\bfseries{scale}} -\/ scale is used to change the magnitude of {\ttfamily Approx} for relative check. {\itshape By default set to {\ttfamily 0.\+0}.}
\end{DoxyItemize}\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md148}{}\doxysubsubsubsection{\texorpdfstring{epsilon example}{epsilon example}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md148}

\begin{DoxyCode}{0}
\DoxyCodeLine{Approx\ target\ =\ Approx(100).epsilon(0.01);}
\DoxyCodeLine{100.0\ ==\ target;\ \textcolor{comment}{//\ Obviously\ true}}
\DoxyCodeLine{200.0\ ==\ target;\ \textcolor{comment}{//\ Obviously\ still\ false}}
\DoxyCodeLine{100.5\ ==\ target;\ \textcolor{comment}{//\ True,\ because\ we\ set\ target\ to\ allow\ up\ to\ 1\%\ difference}}

\end{DoxyCode}
\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md149}{}\doxysubsubsubsection{\texorpdfstring{margin example}{margin example}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md149}

\begin{DoxyCode}{0}
\DoxyCodeLine{Approx\ target\ =\ Approx(100).margin(5);}
\DoxyCodeLine{100.0\ ==\ target;\ \textcolor{comment}{//\ Obviously\ true}}
\DoxyCodeLine{200.0\ ==\ target;\ \textcolor{comment}{//\ Obviously\ still\ false}}
\DoxyCodeLine{104.0\ ==\ target;\ \textcolor{comment}{//\ True,\ because\ we\ set\ target\ to\ allow\ absolute\ difference\ of\ at\ most\ 5}}

\end{DoxyCode}
\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md150}{}\doxysubsubsubsection{\texorpdfstring{scale}{scale}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md150}
Scale can be useful if the computation leading to the result worked on different scale than is used by the results. Since allowed difference between Approx\textquotesingle{}s value and compared value is based primarily on Approx\textquotesingle{}s value (the allowed difference is computed as {\ttfamily (Approx\+::scale + Approx\+::value) \texorpdfstring{$\ast$}{*} epsilon}), the resulting comparison could need rescaling to be correct.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md151}{}\doxysubsection{\texorpdfstring{Exceptions}{Exceptions}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md151}

\begin{DoxyItemize}
\item {\bfseries{REQUIRE\+\_\+\+NOTHROW(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape expression} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}} and ~\newline

\item {\bfseries{CHECK\+\_\+\+NOTHROW(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape expression} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}}
\end{DoxyItemize}

Expects that no exception is thrown during evaluation of the expression.


\begin{DoxyItemize}
\item {\bfseries{REQUIRE\+\_\+\+THROWS(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape expression} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}} and ~\newline

\item {\bfseries{CHECK\+\_\+\+THROWS(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape expression} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}}
\end{DoxyItemize}

Expects that an exception (of any type) is be thrown during evaluation of the expression.


\begin{DoxyItemize}
\item {\bfseries{REQUIRE\+\_\+\+THROWS\+\_\+\+AS(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape expression}, {\itshape exception type} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}} and ~\newline

\item {\bfseries{CHECK\+\_\+\+THROWS\+\_\+\+AS(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape expression}, {\itshape exception type} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}}
\end{DoxyItemize}

Expects that an exception of the {\itshape specified type} is thrown during evaluation of the expression. Note that the {\itshape exception type} is extended with {\ttfamily const\&} and you should not include it yourself.


\begin{DoxyItemize}
\item {\bfseries{REQUIRE\+\_\+\+THROWS\+\_\+\+WITH(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape expression}, {\itshape string or string matcher} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}} and ~\newline

\item {\bfseries{CHECK\+\_\+\+THROWS\+\_\+\+WITH(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape expression}, {\itshape string or string matcher} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}}
\end{DoxyItemize}

Expects that an exception is thrown that, when converted to a string, matches the {\itshape string} or {\itshape string matcher} provided (see next section for Matchers).

e.\+g. 
\begin{DoxyCode}{0}
\DoxyCodeLine{REQUIRE\_THROWS\_WITH(\ openThePodBayDoors(),\ Contains(\ \textcolor{stringliteral}{"{}afraid"{}}\ )\ \&\&\ Contains(\ \textcolor{stringliteral}{"{}can't\ do\ that"{}}\ )\ );}
\DoxyCodeLine{REQUIRE\_THROWS\_WITH(\ dismantleHal(),\ \textcolor{stringliteral}{"{}My\ mind\ is\ going"{}}\ );}

\end{DoxyCode}



\begin{DoxyItemize}
\item {\bfseries{REQUIRE\+\_\+\+THROWS\+\_\+\+MATCHES(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape expression}, {\itshape exception type}, {\itshape matcher for given exception type} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}} and
\item {\bfseries{CHECK\+\_\+\+THROWS\+\_\+\+MATCHES(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape expression}, {\itshape exception type}, {\itshape matcher for given exception type} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}}
\end{DoxyItemize}

Expects that exception of {\itshape exception type} is thrown and it matches provided matcher (see the \href{matchers.md\#top}{\texttt{ documentation for Matchers}}).

{\itshape Please note that the {\ttfamily THROW} family of assertions expects to be passed a single expression, not a statement or series of statements. If you want to check a more complicated sequence of operations, you can use a C++11 lambda function.}


\begin{DoxyCode}{0}
\DoxyCodeLine{REQUIRE\_NOTHROW([\&]()\{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{int}\ i\ =\ 1;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{int}\ j\ =\ 2;}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ k\ =\ i\ +\ j;}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{if}\ (k\ ==\ 3)\ \{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{throw}\ 1;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\}());}

\end{DoxyCode}
\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md152}{}\doxysubsection{\texorpdfstring{Matcher expressions}{Matcher expressions}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md152}
To support Matchers a slightly different form is used. Matchers have \href{matchers.md\#top}{\texttt{ their own documentation}}.


\begin{DoxyItemize}
\item {\bfseries{REQUIRE\+\_\+\+THAT(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape lhs}, {\itshape matcher expression} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}} and ~\newline

\item {\bfseries{CHECK\+\_\+\+THAT(\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\itshape lhs}, {\itshape matcher expression} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*})}} ~\newline

\end{DoxyItemize}

Matchers can be composed using {\ttfamily \&\&}, {\ttfamily \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|}} and {\ttfamily !} operators.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md153}{}\doxysubsection{\texorpdfstring{Thread Safety}{Thread Safety}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md153}
Currently assertions in Catch are not thread safe. For more details, along with workarounds, see the section on \href{limitations.md\#thread-safe-assertions}{\texttt{ the limitations page}}.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md154}{}\doxysubsection{\texorpdfstring{Expressions with commas}{Expressions with commas}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bu8494b4fec008f8e2cb2a76adab044425_autotoc_md154}
Because the preprocessor parses code using different rules than the compiler, multiple-\/argument assertions (e.\+g. {\ttfamily REQUIRE\+\_\+\+THROWS\+\_\+\+AS}) have problems with commas inside the provided expressions. As an example {\ttfamily REQUIRE\+\_\+\+THROWS\+\_\+\+AS(std\+::pair\texorpdfstring{$<$}{<}int, int\texorpdfstring{$>$}{>}(1, 2), std\+::invalid\+\_\+argument);} will fail to compile, because the preprocessor sees 3 arguments provided, but the macro accepts only 2. There are two possible workarounds.

1) Use typedef\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using\ }int\_pair\ =\ std::pair<int,\ int>;}
\DoxyCodeLine{REQUIRE\_THROWS\_AS(int\_pair(1,\ 2),\ std::invalid\_argument);}

\end{DoxyCode}


This solution is always applicable, but makes the meaning of the code less clear.

2) Parenthesize the expression\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{TEST\_CASE\_METHOD((\mbox{\hyperlink{struct_fixture}{Fixture<int,\ int>}}),\ \textcolor{stringliteral}{"{}foo"{}},\ \textcolor{stringliteral}{"{}[bar]"{}})\ \{}
\DoxyCodeLine{\ \ \ \ SUCCEED();}
\DoxyCodeLine{\}}

\end{DoxyCode}


This solution is not always applicable, because it might require extra changes on the Catch\textquotesingle{}s side to work.

\DoxyHorRuler{0}


\href{Readme.md\#top}{\texttt{ Home}} 