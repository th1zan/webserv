\chapter{matchers}
\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c}{}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c}\index{matchers@{matchers}}
\label{_top}%
 \hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md309}{}\doxysection{\texorpdfstring{Matchers}{Matchers}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md309}
Matchers are an alternative way to do assertions which are easily extensible and composable. This makes them well suited to use with more complex types (such as collections) or your own custom types. Matchers were first popularised by the \href{https://en.wikipedia.org/wiki/Hamcrest}{\texttt{ Hamcrest}} family of frameworks.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md310}{}\doxysubsection{\texorpdfstring{In use}{In use}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md310}
Matchers are introduced with the {\ttfamily REQUIRE\+\_\+\+THAT} or {\ttfamily CHECK\+\_\+\+THAT} macros, which take two arguments. The first argument is the thing (object or value) under test. The second part is a match {\itshape expression}, which consists of either a single matcher or one or more matchers combined using {\ttfamily \&\&}, {\ttfamily \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|}} or {\ttfamily !} operators.

For example, to assert that a string ends with a certain substring\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\textcolor{keyword}{using\ }Catch::Matchers::EndsWith;\ \textcolor{comment}{//\ or\ Catch::EndsWith}}
\DoxyCodeLine{std::string\ str\ =\ getStringFromSomewhere();}
\DoxyCodeLine{REQUIRE\_THAT(\ str,\ EndsWith(\ \textcolor{stringliteral}{"{}as\ a\ service"{}}\ )\ );}

\end{DoxyCode}


The matcher objects can take multiple arguments, allowing more fine tuning. The built-\/in string matchers, for example, take a second argument specifying whether the comparison is case sensitive or not\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{REQUIRE\_THAT(\ str,\ EndsWith(\ \textcolor{stringliteral}{"{}as\ a\ service"{}},\ Catch::CaseSensitive::No\ )\ );}

\end{DoxyCode}


And matchers can be combined\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{REQUIRE\_THAT(\ str,}
\DoxyCodeLine{\ \ \ \ EndsWith(\ \textcolor{stringliteral}{"{}as\ a\ service"{}}\ )\ ||}
\DoxyCodeLine{\ \ \ \ (StartsWith(\ \textcolor{stringliteral}{"{}Big\ data"{}}\ )\ \&\&\ !Contains(\ \textcolor{stringliteral}{"{}web\ scale"{}}\ )\ )\ );}

\end{DoxyCode}


{\itshape The combining operators do not take ownership of the matcher objects. This means that if you store the combined object, you have to ensure that the matcher objects outlive its last use. What this means is that code like this leads to a use-\/after-\/free and (hopefully) a crash\+:}


\begin{DoxyCode}{0}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}Bugs,\ bugs,\ bugs"{}},\ \textcolor{stringliteral}{"{}[Bug]"{}})\{}
\DoxyCodeLine{\ \ \ \ std::string\ str\ =\ \textcolor{stringliteral}{"{}Bugs\ as\ a\ service"{}};}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{auto}\ match\_expression\ =\ Catch::EndsWith(\ \textcolor{stringliteral}{"{}as\ a\ service"{}}\ )\ ||}
\DoxyCodeLine{\ \ \ \ \ \ \ \ (Catch::StartsWith(\ \textcolor{stringliteral}{"{}Big\ data"{}}\ )\ \&\&\ !Catch::Contains(\ \textcolor{stringliteral}{"{}web\ scale"{}}\ )\ );}
\DoxyCodeLine{\ \ \ \ REQUIRE\_THAT(str,\ match\_expression);}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md311}{}\doxysubsection{\texorpdfstring{Built in matchers}{Built in matchers}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md311}
Catch2 provides some matchers by default. They can be found in the {\ttfamily Catch\+::\+Matchers\+::foo} namespace and are imported into the {\ttfamily Catch} namespace as well.

There are two parts to each of the built-\/in matchers, the matcher type itself and a helper function that provides template argument deduction when creating templated matchers. As an example, the matcher for checking that two instances of {\ttfamily std\+::vector} are identical is {\ttfamily Equals\+Matcher\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}}, but the user is expected to use the {\ttfamily Equals} helper function instead.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md312}{}\doxysubsubsection{\texorpdfstring{String matchers}{String matchers}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md312}
The string matchers are {\ttfamily Starts\+With}, {\ttfamily Ends\+With}, {\ttfamily Contains}, {\ttfamily Equals} and {\ttfamily Matches}. The first four match a literal (sub)string against a result, while {\ttfamily Matches} takes and matches an ECMAScript regex. Do note that {\ttfamily Matches} matches the string as a whole, meaning that "{}abc"{} will not match against "{}abcd"{}, but "{}abc.\texorpdfstring{$\ast$}{*}"{} will.

Each of the provided {\ttfamily std\+::string} matchers also takes an optional second argument, that decides case sensitivity (by-\/default, they are case sensitive).\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md313}{}\doxysubsubsection{\texorpdfstring{Vector matchers}{Vector matchers}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md313}
Catch2 currently provides 5 built-\/in matchers that work on {\ttfamily std\+::vector}. These are


\begin{DoxyItemize}
\item {\ttfamily Contains} which checks whether a specified vector is present in the result
\item {\ttfamily Vector\+Contains} which checks whether a specified element is present in the result
\item {\ttfamily Equals} which checks whether the result is exactly equal (order matters) to a specific vector
\item {\ttfamily Unordered\+Equals} which checks whether the result is equal to a specific vector under a permutation
\item {\ttfamily Approx} which checks whether the result is "{}approx-\/equal"{} (order matters, but comparison is done via {\ttfamily Approx}) to a specific vector \begin{quote}
Approx matcher was \href{https://github.com/catchorg/Catch2/issues/1499}{\texttt{ introduced}} in Catch 2.\+7.\+2. \end{quote}

\end{DoxyItemize}\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md314}{}\doxysubsubsection{\texorpdfstring{Floating point matchers}{Floating point matchers}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md314}
Catch2 provides 3 matchers for working with floating point numbers. These are {\ttfamily Within\+Abs\+Matcher}, {\ttfamily Within\+Ulps\+Matcher} and {\ttfamily Within\+Rel\+Matcher}.

The {\ttfamily Within\+Abs\+Matcher} matcher accepts floating point numbers that are within a certain distance of target. It should be constructed with the {\ttfamily Within\+Abs(double target, double margin)} helper.

The {\ttfamily Within\+Ulps\+Matcher} matcher accepts floating point numbers that are within a certain number of \href{https://en.wikipedia.org/wiki/Unit_in_the_last_place}{\texttt{ ULPs}} of the target. Because ULP comparisons need to be done differently for {\ttfamily float}s and for {\ttfamily double}s, there are two overloads of the helpers for this matcher, {\ttfamily Within\+ULP(float target, int64\+\_\+t ULPs)}, and {\ttfamily Within\+ULP(double target, int64\+\_\+t ULPs)}.

The {\ttfamily Within\+Rel\+Matcher} matcher accepts floating point numbers that are {\itshape approximately equal} with the target number with some specific tolerance. In other words, it checks that {\ttfamily \texorpdfstring{$\vert$}{|}lhs -\/ rhs\texorpdfstring{$\vert$}{|} \texorpdfstring{$<$}{<}= epsilon \texorpdfstring{$\ast$}{*} max(\texorpdfstring{$\vert$}{|}lhs\texorpdfstring{$\vert$}{|}, \texorpdfstring{$\vert$}{|}rhs\texorpdfstring{$\vert$}{|})}, with special casing for {\ttfamily INFINITY} and {\ttfamily NaN}. There are {\itshape 4} overloads of the helpers for this matcher, {\ttfamily Within\+Rel(double target, double margin)}, {\ttfamily Within\+Rel(float target, float margin)}, {\ttfamily Within\+Rel(double target)}, and {\ttfamily Within\+Rel(float target)}. The latter two provide a default epsilon of machine epsilon \texorpdfstring{$\ast$}{*} 100.

\begin{quote}
{\ttfamily Within\+Rel} matcher was introduced in Catch 2.\+10.\+0 \end{quote}
\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md315}{}\doxysubsubsection{\texorpdfstring{Generic matchers}{Generic matchers}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md315}
Catch also aims to provide a set of generic matchers. Currently this set contains only a matcher that takes arbitrary callable predicate and applies it onto the provided object.

Because of type inference limitations, the argument type of the predicate has to be provided explicitly. Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{REQUIRE\_THAT(\textcolor{stringliteral}{"{}Hello\ olleH"{}},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ Predicate<std::string>(}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ []\ (std::string\ \textcolor{keyword}{const}\&\ str)\ -\/>\ \textcolor{keywordtype}{bool}\ \{\ \textcolor{keywordflow}{return}\ str.front()\ ==\ str.back();\ \},}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}First\ and\ last\ character\ should\ be\ equal"{}})}
\DoxyCodeLine{);}

\end{DoxyCode}


The second argument is an optional description of the predicate, and is used only during reporting of the result.\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md316}{}\doxysubsubsection{\texorpdfstring{Exception matchers}{Exception matchers}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md316}
Catch2 also provides an exception matcher that can be used to verify that an exception\textquotesingle{}s message exactly matches desired string. The matcher is {\ttfamily Exception\+Message\+Matcher}, and we also provide a helper function {\ttfamily Message}.

The matched exception must publicly derive from {\ttfamily std\+::exception} and the message matching is done {\itshape exactly}, including case.

\begin{quote}
{\ttfamily Exception\+Message\+Matcher} was introduced in Catch 2.\+10.\+0 \end{quote}
Example use\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{REQUIRE\_THROWS\_MATCHES(throwsDerivedException(),\ \ DerivedException,\ \ Message(\textcolor{stringliteral}{"{}DerivedException::what"{}}));}

\end{DoxyCode}
\hypertarget{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md317}{}\doxysubsection{\texorpdfstring{Custom matchers}{Custom matchers}}\label{md__2_users_2thibault_2kdrive_21-_p_r_o_j_e_c_t_s_2_p-42_2push__swap_2push__swap__visualizer_2bue51352cbc84deeab167146baa216362c_autotoc_md317}
It\textquotesingle{}s easy to provide your own matchers to extend Catch or just to work with your own types.

You need to provide two things\+:
\begin{DoxyEnumerate}
\item \doxylink{class_a}{A} matcher class, derived from {\ttfamily Catch\+::\+Matcher\+Base\texorpdfstring{$<$}{<}T\texorpdfstring{$>$}{>}} -\/ where {\ttfamily T} is the type being tested. The constructor takes and stores any arguments needed (e.\+g. something to compare against) and you must override two methods\+: {\ttfamily match()} and {\ttfamily describe()}.
\item \doxylink{class_a}{A} simple builder function. This is what is actually called from the test code and allows overloading.
\end{DoxyEnumerate}

Here\textquotesingle{}s an example for asserting that an integer falls within a given range (note that it is all inline for the sake of keeping the example short)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\ ++}
\DoxyCodeLine{\textcolor{comment}{//\ The\ matcher\ class}}
\DoxyCodeLine{\textcolor{keyword}{class\ }IntRange\ :\ \textcolor{keyword}{public}\ \mbox{\hyperlink{struct_catch_1_1_matchers_1_1_impl_1_1_matcher_base}{Catch::MatcherBase}}<int>\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{int}\ m\_begin,\ m\_end;}
\DoxyCodeLine{\textcolor{keyword}{public}:}
\DoxyCodeLine{\ \ \ \ IntRange(\ \textcolor{keywordtype}{int}\ begin,\ \textcolor{keywordtype}{int}\ end\ )\ :\ m\_begin(\ begin\ ),\ m\_end(\ end\ )\ \{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Performs\ the\ test\ for\ this\ matcher}}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordtype}{bool}\ match(\ \textcolor{keywordtype}{int}\ \textcolor{keyword}{const}\&\ i\ )\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ i\ >=\ m\_begin\ \&\&\ i\ <=\ m\_end;}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ Produces\ a\ string\ describing\ what\ this\ matcher\ does.\ It\ should}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ include\ any\ provided\ data\ (the\ begin/\ end\ in\ this\ case)\ and}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ be\ written\ as\ if\ it\ were\ stating\ a\ fact\ (in\ the\ output\ it\ will\ be}}
\DoxyCodeLine{\ \ \ \ \textcolor{comment}{//\ preceded\ by\ the\ value\ under\ test).}}
\DoxyCodeLine{\ \ \ \ \textcolor{keyword}{virtual}\ std::string\ describe()\textcolor{keyword}{\ const\ override\ }\{}
\DoxyCodeLine{\ \ \ \ \ \ \ \ std::ostringstream\ ss;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ ss\ <<\ \textcolor{stringliteral}{"{}is\ between\ "{}}\ <<\ m\_begin\ <<\ \textcolor{stringliteral}{"{}\ and\ "{}}\ <<\ m\_end;}
\DoxyCodeLine{\ \ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ ss.str();}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ The\ builder\ function}}
\DoxyCodeLine{\textcolor{keyword}{inline}\ IntRange\ IsBetween(\ \textcolor{keywordtype}{int}\ begin,\ \textcolor{keywordtype}{int}\ end\ )\ \{}
\DoxyCodeLine{\ \ \ \ \textcolor{keywordflow}{return}\ IntRange(\ begin,\ end\ );}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ ...}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{//\ Usage}}
\DoxyCodeLine{TEST\_CASE(\textcolor{stringliteral}{"{}Integers\ are\ within\ a\ range"{}})}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ \ \ CHECK\_THAT(\ 3,\ IsBetween(\ 1,\ 10\ )\ );}
\DoxyCodeLine{\ \ \ \ CHECK\_THAT(\ 100,\ IsBetween(\ 1,\ 10\ )\ );}
\DoxyCodeLine{\}}

\end{DoxyCode}


Running this test gives the following in the console\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{/**/TestFile.cpp:123:\ FAILED:}
\DoxyCodeLine{\ \ CHECK\_THAT(\ 100,\ IsBetween(\ 1,\ 10\ )\ )}
\DoxyCodeLine{with\ expansion:}
\DoxyCodeLine{\ \ 100\ is\ between\ 1\ and\ 10}

\end{DoxyCode}


\DoxyHorRuler{0}


\href{Readme.md\#top}{\texttt{ Home}} 