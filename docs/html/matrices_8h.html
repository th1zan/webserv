<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Webserv: /Users/thibault/kdrive/1-PROJECTS/P-42/miniRT/miniRT_example/include/matrices.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Webserv
   </div>
   <div id="projectbrief">Webserv handle HTML request GET,POST, DELETE and CGI</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_718d3a50777231dd8431e1083e4f3fd5.html">miniRT</a></li><li class="navelem"><a class="el" href="dir_386ffe50f47c159469918f722adcf4a1.html">miniRT_example</a></li><li class="navelem"><a class="el" href="dir_896ef8f67fe720884712a3da1b4385a0.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">matrices.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;libft.h&quot;</code><br />
<code>#include &quot;<a class="el" href="tuples_8h_source.html">tuples.h</a>&quot;</code><br />
</div>
<p><a href="matrices_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structs__matrix.html">s_matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The struct t_matrix stores a matrix up to 4x4 and size of 16. <a class="el" href="class_a.html">A</a> matrix is a grid of numbers that can be manipulated as a single unit. Matrices and their operations are the foundational basis which will helps us to manipulate points, vectors and, ultimately, shapes.  <a href="structs__matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structs__shearing.html">s_shearing</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The struct t_shearing is a helper type to allow shearing operation on matrices. Shearing (or skew) is a complex operation where the coordinate is changed in proportion to the other two coordinates. When doing it to a matrix, it means that x will change in proportion to y and z, y will change in proportion to x and z and, lastly, z will change in proportion to x and y. For example, to apply shearing to the x axis of a given matrix, we pass to <a class="el" href="#aab8a1e820c4bde5ca4973638bc86dcb7" title="This function applies shearing (or skew) transformation to a given matrix. It has the effect of makin...">shearing()</a> a struct of type t_shearing containing the y and z values. For instance, when done to the y axis, we pass p1 and p2 which stands for x and z. Lastly, when applying it to the z axis, we pass x and y as p1 and p2, respectively.  <a href="structs__shearing.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a392fb874e547e582e9c66a08a1f23326" id="r_a392fb874e547e582e9c66a08a1f23326"><td class="memItemLeft" align="right" valign="top"><a id="a392fb874e547e582e9c66a08a1f23326" name="a392fb874e547e582e9c66a08a1f23326"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>MAX</b>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a392fb874e547e582e9c66a08a1f23326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ed59adcb4159ac551058053e649640" id="r_a70ed59adcb4159ac551058053e649640"><td class="memItemLeft" align="right" valign="top"><a id="a70ed59adcb4159ac551058053e649640" name="a70ed59adcb4159ac551058053e649640"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>SIZE</b>&#160;&#160;&#160;16</td></tr>
<tr class="separator:a70ed59adcb4159ac551058053e649640"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab8f0736cc5d493e5ce876dd2550ab88a" id="r_ab8f0736cc5d493e5ce876dd2550ab88a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structs__matrix.html">s_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a></td></tr>
<tr class="memdesc:ab8f0736cc5d493e5ce876dd2550ab88a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The struct t_matrix stores a matrix up to 4x4 and size of 16. <a class="el" href="class_a.html">A</a> matrix is a grid of numbers that can be manipulated as a single unit. Matrices and their operations are the foundational basis which will helps us to manipulate points, vectors and, ultimately, shapes.  <br /></td></tr>
<tr class="separator:ab8f0736cc5d493e5ce876dd2550ab88a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d11cf3a94303cb0fdf026513e23087" id="r_a37d11cf3a94303cb0fdf026513e23087"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structs__shearing.html">s_shearing</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37d11cf3a94303cb0fdf026513e23087">t_shearing</a></td></tr>
<tr class="memdesc:a37d11cf3a94303cb0fdf026513e23087"><td class="mdescLeft">&#160;</td><td class="mdescRight">The struct t_shearing is a helper type to allow shearing operation on matrices. Shearing (or skew) is a complex operation where the coordinate is changed in proportion to the other two coordinates. When doing it to a matrix, it means that x will change in proportion to y and z, y will change in proportion to x and z and, lastly, z will change in proportion to x and y. For example, to apply shearing to the x axis of a given matrix, we pass to <a class="el" href="#aab8a1e820c4bde5ca4973638bc86dcb7" title="This function applies shearing (or skew) transformation to a given matrix. It has the effect of makin...">shearing()</a> a struct of type t_shearing containing the y and z values. For instance, when done to the y axis, we pass p1 and p2 which stands for x and z. Lastly, when applying it to the z axis, we pass x and y as p1 and p2, respectively.  <br /></td></tr>
<tr class="separator:a37d11cf3a94303cb0fdf026513e23087"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a225ddd97ed6ed5ec894b3f555213790b" id="r_a225ddd97ed6ed5ec894b3f555213790b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a225ddd97ed6ed5ec894b3f555213790b">multiply_mx_mx</a> (<a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> a, <a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> b)</td></tr>
<tr class="memdesc:a225ddd97ed6ed5ec894b3f555213790b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function multiplies two matrices. "Mx" means matrix. For more information about how matrix multiplication works, refer to the book TRTC on page 28.  <br /></td></tr>
<tr class="separator:a225ddd97ed6ed5ec894b3f555213790b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff35de74d9504480cbdf50df468fcd4d" id="r_aff35de74d9504480cbdf50df468fcd4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="tuples_8h.html#a2169f9a7bb6d3ded00c7d8a718af65af">t_tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff35de74d9504480cbdf50df468fcd4d">multiply_tp_mx</a> (<a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> a, <a class="el" href="tuples_8h.html#a2169f9a7bb6d3ded00c7d8a718af65af">t_tuple</a> b)</td></tr>
<tr class="memdesc:aff35de74d9504480cbdf50df468fcd4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function multiplies a matrix by a tuple. "Mx" means matrix and "tp" means tuple. For more information about how vector and matrix multiplication works, refer to the following link quoted by author J. Buck: <a href="https://betterexplained.com/articles/linear-algebra-guide/">https://betterexplained.com/articles/linear-algebra-guide/</a>.  <br /></td></tr>
<tr class="separator:aff35de74d9504480cbdf50df468fcd4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3c75778a90d4d4ef95cf08bd7c625d" id="r_a8d3c75778a90d4d4ef95cf08bd7c625d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d3c75778a90d4d4ef95cf08bd7c625d">transpose</a> (<a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> t)</td></tr>
<tr class="memdesc:a8d3c75778a90d4d4ef95cf08bd7c625d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function transposes the matrix passed to the function as parameter. In other words, it turns the first row into the first column, the second row into the second column, and so forth. Thus, it's importante to remember that the transpose of the identity matrix always gives the own identity matrix as result.  <br /></td></tr>
<tr class="separator:a8d3c75778a90d4d4ef95cf08bd7c625d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18f12a98d0aff3b1aba4a4b7c1a4a72" id="r_ad18f12a98d0aff3b1aba4a4b7c1a4a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad18f12a98d0aff3b1aba4a4b7c1a4a72">inverse</a> (<a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> t)</td></tr>
<tr class="memdesc:ad18f12a98d0aff3b1aba4a4b7c1a4a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function get the inverse of a given matrix. That is, if you multiply some matrix <a class="el" href="class_a.html">A</a> by another matrix <a class="el" href="class_b.html">B</a>, producing <a class="el" href="class_c.html">C</a>, you can multiply <a class="el" href="class_c.html">C</a> by the inverse of <a class="el" href="class_b.html">B</a> to get <a class="el" href="class_a.html">A</a> again. To invert the matrix, this function employs a method known as cofactor expansion. Additionally, there some interesting properties of the inverse: 1) if you invert an identity matrix, the result is also an identity matrix. 2) when you multiply a matrix by its inverse, you get as result the identity matrix. 3) The inverse of the transpose of a matrix and the transpose of the inverse only commute if the matrix is symmetric or orthogonal. Otherwise, the result of the two operations will always be different.  <br /></td></tr>
<tr class="separator:ad18f12a98d0aff3b1aba4a4b7c1a4a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66482775137fa71d5eaf2605358e33d7" id="r_a66482775137fa71d5eaf2605358e33d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66482775137fa71d5eaf2605358e33d7">translation</a> (double x, double y, double z)</td></tr>
<tr class="memdesc:a66482775137fa71d5eaf2605358e33d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function translates a given matrix. Translation is a transformation that moves a point. Thus, it's important to note that the inverse of a translation matrix is another translation matrix that moves points in reverse.  <br /></td></tr>
<tr class="separator:a66482775137fa71d5eaf2605358e33d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3448d79c382a6160f3bb09b901a114d1" id="r_a3448d79c382a6160f3bb09b901a114d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3448d79c382a6160f3bb09b901a114d1">scaling</a> (double x, double y, double z)</td></tr>
<tr class="memdesc:a3448d79c382a6160f3bb09b901a114d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function scales a given matrix by multiplication. When applied to an object centered at the origin, this transformation scales all points on the object, effectively making it larger (if the scale value is greater than 1) or smaller (if the scale value is less than 1). Note that reflection is scaling by a negative value.  <br /></td></tr>
<tr class="separator:a3448d79c382a6160f3bb09b901a114d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8a1e820c4bde5ca4973638bc86dcb7" id="r_aab8a1e820c4bde5ca4973638bc86dcb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab8a1e820c4bde5ca4973638bc86dcb7">shearing</a> (<a class="el" href="#a37d11cf3a94303cb0fdf026513e23087">t_shearing</a> x, <a class="el" href="#a37d11cf3a94303cb0fdf026513e23087">t_shearing</a> y, <a class="el" href="#a37d11cf3a94303cb0fdf026513e23087">t_shearing</a> z)</td></tr>
<tr class="memdesc:aab8a1e820c4bde5ca4973638bc86dcb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function applies shearing (or skew) transformation to a given matrix. It has the effect of making straight lines slanted. Each coordinate is changed in proportion to the other two coordinates. When doing it to a matrix, it means that x will change in proportion to y and z, y will change in proportion to x and z and, lastly, z will change in proportion to x and y.  <br /></td></tr>
<tr class="separator:aab8a1e820c4bde5ca4973638bc86dcb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58db7b9fdc1a5e8b4ad8db66f113738" id="r_aa58db7b9fdc1a5e8b4ad8db66f113738"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa58db7b9fdc1a5e8b4ad8db66f113738">rotation_x</a> (double rad)</td></tr>
<tr class="memdesc:aa58db7b9fdc1a5e8b4ad8db66f113738"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function rotates a given matrix around the x-axis.  <br /></td></tr>
<tr class="separator:aa58db7b9fdc1a5e8b4ad8db66f113738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3184c113edb90be69bec3e2355b40a23" id="r_a3184c113edb90be69bec3e2355b40a23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3184c113edb90be69bec3e2355b40a23">rotation_y</a> (double rad)</td></tr>
<tr class="memdesc:a3184c113edb90be69bec3e2355b40a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function rotates a given matrix around the y-axis.  <br /></td></tr>
<tr class="separator:a3184c113edb90be69bec3e2355b40a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c926cae7f2423369039f0711a2d717" id="r_a14c926cae7f2423369039f0711a2d717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14c926cae7f2423369039f0711a2d717">rotation_z</a> (double rad)</td></tr>
<tr class="memdesc:a14c926cae7f2423369039f0711a2d717"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function rotates a given matrix around the z-axis.  <br /></td></tr>
<tr class="separator:a14c926cae7f2423369039f0711a2d717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e47eb1e76ebbc004e33b423797e8e6" id="r_a12e47eb1e76ebbc004e33b423797e8e6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12e47eb1e76ebbc004e33b423797e8e6">get_determinant</a> (<a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> t)</td></tr>
<tr class="memdesc:a12e47eb1e76ebbc004e33b423797e8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the determinant of a given matrix. The determinant is a number that is derived from the elements of a matrix. The name comes from the use of matrices to solve systems of equations, where it’s used to determine whether or not the system has a solution. If the determinant is zero, then the corresponding system of equations has no solution.  <br /></td></tr>
<tr class="separator:a12e47eb1e76ebbc004e33b423797e8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7df591ed1926b001ac7e2714b46a1db" id="r_ab7df591ed1926b001ac7e2714b46a1db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7df591ed1926b001ac7e2714b46a1db">get_submatrix</a> (<a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> t, size_t del_row, size_t del_col)</td></tr>
<tr class="memdesc:ab7df591ed1926b001ac7e2714b46a1db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This functions gets the submatrix of a given matrix. That is, what is left when you delete a single row and column from a matrix. The submatrix of a 4x4 matrix is 3x3 and the submatrix of a 3x3 matrix is 2x2.  <br /></td></tr>
<tr class="separator:ab7df591ed1926b001ac7e2714b46a1db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc6a53ecf6c2f3f596d30db85181fb9" id="r_a6cc6a53ecf6c2f3f596d30db85181fb9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6cc6a53ecf6c2f3f596d30db85181fb9">get_minor</a> (<a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> t, size_t row, size_t col)</td></tr>
<tr class="memdesc:a6cc6a53ecf6c2f3f596d30db85181fb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the minor of a given matrix. To put it differently, the minor of an element at row i and column j is the determinant of the submatrix at (i,j).  <br /></td></tr>
<tr class="separator:a6cc6a53ecf6c2f3f596d30db85181fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f4ce538ae4c42221e9e7674649a784" id="r_ad9f4ce538ae4c42221e9e7674649a784"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9f4ce538ae4c42221e9e7674649a784">get_cofactor</a> (<a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> t, size_t row, size_t col)</td></tr>
<tr class="memdesc:ad9f4ce538ae4c42221e9e7674649a784"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the cofactor of a given matrix. Cofactors are minors that have (possibly) had their sign changed. If row + column equals to an odd number as result, the minor must be negated. Therefore, if the row and column identifies a spot with a +, then the minor’s sign doesn’t change. If the row and column identifies a spot with a -, then the minor must be negated.  <br /></td></tr>
<tr class="separator:ad9f4ce538ae4c42221e9e7674649a784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053b1f857b70fdc5b36b325d585c8745" id="r_a053b1f857b70fdc5b36b325d585c8745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a053b1f857b70fdc5b36b325d585c8745">get_identity_matrix</a> (void)</td></tr>
<tr class="memdesc:a053b1f857b70fdc5b36b325d585c8745"><td class="mdescLeft">&#160;</td><td class="mdescRight">This fucntion gets a new matrix with the special attribute of being an identity matrix or multiplicative identity. That is, if you multiply any matrix or tuple by the identity matrix, you get back the matrix or tuple you started with.  <br /></td></tr>
<tr class="separator:a053b1f857b70fdc5b36b325d585c8745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace76bdd2f0e2d46c0ed458d89584edc2" id="r_ace76bdd2f0e2d46c0ed458d89584edc2"><td class="memItemLeft" align="right" valign="top"><a id="ace76bdd2f0e2d46c0ed458d89584edc2" name="ace76bdd2f0e2d46c0ed458d89584edc2"></a>
<a class="el" href="#a37d11cf3a94303cb0fdf026513e23087">t_shearing</a>&#160;</td><td class="memItemRight" valign="bottom"><b>to_shear</b> (double a, double b)</td></tr>
<tr class="separator:ace76bdd2f0e2d46c0ed458d89584edc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f5f462841ae8fb8678e95af2cf74a0" id="r_ac6f5f462841ae8fb8678e95af2cf74a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6f5f462841ae8fb8678e95af2cf74a0">create_matrix</a> (const double table[MAX][MAX], size_t size)</td></tr>
<tr class="memdesc:ac6f5f462841ae8fb8678e95af2cf74a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function creates a matrix up to 4x4 and, therefore, size of 16 (4x4). For instance, a matrix of 3x3 will have a size of 9(3x3).  <br /></td></tr>
<tr class="separator:ac6f5f462841ae8fb8678e95af2cf74a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed57a65ff975cfb1a29541b7cb923ab" id="r_a4ed57a65ff975cfb1a29541b7cb923ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ed57a65ff975cfb1a29541b7cb923ab">compare_matrix</a> (<a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> a, <a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> b)</td></tr>
<tr class="memdesc:a4ed57a65ff975cfb1a29541b7cb923ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function <a class="el" href="#a4ed57a65ff975cfb1a29541b7cb923ab" title="The function compare_matrix() checks if two matrices are identical or not. The matrices passed as par...">compare_matrix()</a> checks if two matrices are identical or not. The matrices passed as parameter to the function are compared with ft_memcmp().  <br /></td></tr>
<tr class="separator:a4ed57a65ff975cfb1a29541b7cb923ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9e09e616d4b4683ba17c892826a722" id="r_aab9e09e616d4b4683ba17c892826a722"><td class="memItemLeft" align="right" valign="top">t_bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab9e09e616d4b4683ba17c892826a722">is_invertible</a> (<a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> t)</td></tr>
<tr class="memdesc:aab9e09e616d4b4683ba17c892826a722"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function checks if a given matrix is invertible or not. Not every matrix is invertible. An matrix is invertible if its determinant is a non-zero number. If its determinant is 0, then the given matrix is not invertible.  <br /></td></tr>
<tr class="separator:aab9e09e616d4b4683ba17c892826a722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab102c4ab11629464f6eec87eaa182825" id="r_ab102c4ab11629464f6eec87eaa182825"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab102c4ab11629464f6eec87eaa182825">rotation_matrix</a> (<a class="el" href="tuples_8h.html#aea609bcc1e9134165bc86014c7974ec7">t_vector</a> <a class="el" href="tuples_8h.html#a3d1d2f7d5266743d5a19a0a246d39064">vector</a>)</td></tr>
<tr class="memdesc:ab102c4ab11629464f6eec87eaa182825"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the rotation matrix for a given vector.  <br /></td></tr>
<tr class="separator:ab102c4ab11629464f6eec87eaa182825"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ab8f0736cc5d493e5ce876dd2550ab88a" name="ab8f0736cc5d493e5ce876dd2550ab88a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f0736cc5d493e5ce876dd2550ab88a">&#9670;&#160;</a></span>t_matrix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structs__matrix.html">s_matrix</a> <a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The struct t_matrix stores a matrix up to 4x4 and size of 16. <a class="el" href="class_a.html">A</a> matrix is a grid of numbers that can be manipulated as a single unit. Matrices and their operations are the foundational basis which will helps us to manipulate points, vectors and, ultimately, shapes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>Stores a matrix. </td></tr>
    <tr><td class="paramname">size</td><td>Stores the size of the matrix. For example, a matrix of 3x3 has a size of 9. For instance, a 2x2 matrix has a size of 4. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37d11cf3a94303cb0fdf026513e23087" name="a37d11cf3a94303cb0fdf026513e23087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d11cf3a94303cb0fdf026513e23087">&#9670;&#160;</a></span>t_shearing</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structs__shearing.html">s_shearing</a> <a class="el" href="#a37d11cf3a94303cb0fdf026513e23087">t_shearing</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The struct t_shearing is a helper type to allow shearing operation on matrices. Shearing (or skew) is a complex operation where the coordinate is changed in proportion to the other two coordinates. When doing it to a matrix, it means that x will change in proportion to y and z, y will change in proportion to x and z and, lastly, z will change in proportion to x and y. For example, to apply shearing to the x axis of a given matrix, we pass to <a class="el" href="#aab8a1e820c4bde5ca4973638bc86dcb7" title="This function applies shearing (or skew) transformation to a given matrix. It has the effect of makin...">shearing()</a> a struct of type t_shearing containing the y and z values. For instance, when done to the y axis, we pass p1 and p2 which stands for x and z. Lastly, when applying it to the z axis, we pass x and y as p1 and p2, respectively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>The first value to be used as proportion for shearing. </td></tr>
    <tr><td class="paramname">p2</td><td>The second value to be used as proportion for shearing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4ed57a65ff975cfb1a29541b7cb923ab" name="a4ed57a65ff975cfb1a29541b7cb923ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed57a65ff975cfb1a29541b7cb923ab">&#9670;&#160;</a></span>compare_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compare_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function <a class="el" href="#a4ed57a65ff975cfb1a29541b7cb923ab" title="The function compare_matrix() checks if two matrices are identical or not. The matrices passed as par...">compare_matrix()</a> checks if two matrices are identical or not. The matrices passed as parameter to the function are compared with ft_memcmp(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Receives the first matrix to be compared. </td></tr>
    <tr><td class="paramname">b</td><td>Receives the second matrix to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The function returns 0 if the matrices are identical. Otherwise, it returns a non-zero integer. </dd></dl>

</div>
</div>
<a id="ac6f5f462841ae8fb8678e95af2cf74a0" name="ac6f5f462841ae8fb8678e95af2cf74a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f5f462841ae8fb8678e95af2cf74a0">&#9670;&#160;</a></span>create_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> create_matrix </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>table</em></span>[MAX][MAX], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function creates a matrix up to 4x4 and, therefore, size of 16 (4x4). For instance, a matrix of 3x3 will have a size of 9(3x3). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td><a class="el" href="class_a.html">A</a> bidimensional array of const double containing the matrix. </td></tr>
    <tr><td class="paramname">size</td><td><a class="el" href="class_a.html">A</a> size_t value containing how much elements the array has. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns successfully a new matrix created with ft_memmove() from the array and array's size passed as parameter to the function. </dd></dl>

</div>
</div>
<a id="ad9f4ce538ae4c42221e9e7674649a784" name="ad9f4ce538ae4c42221e9e7674649a784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f4ce538ae4c42221e9e7674649a784">&#9670;&#160;</a></span>get_cofactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_cofactor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the cofactor of a given matrix. Cofactors are minors that have (possibly) had their sign changed. If row + column equals to an odd number as result, the minor must be negated. Therefore, if the row and column identifies a spot with a +, then the minor’s sign doesn’t change. If the row and column identifies a spot with a -, then the minor must be negated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Receives the matrix from which the cofactor will be calculated. </td></tr>
    <tr><td class="paramname">row</td><td>Receives the row value from which the cofactor will be calculated. </td></tr>
    <tr><td class="paramname">col</td><td>Receives the column value from which the cofactor will be calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the cofactor of the matrix passed to the function as parameter. </dd></dl>

</div>
</div>
<a id="a12e47eb1e76ebbc004e33b423797e8e6" name="a12e47eb1e76ebbc004e33b423797e8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e47eb1e76ebbc004e33b423797e8e6">&#9670;&#160;</a></span>get_determinant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_determinant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the determinant of a given matrix. The determinant is a number that is derived from the elements of a matrix. The name comes from the use of matrices to solve systems of equations, where it’s used to determine whether or not the system has a solution. If the determinant is zero, then the corresponding system of equations has no solution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Receives the matrix to calculate its determinant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a double value which is the determinant of the matrix passed to the function as parameter. </dd></dl>

</div>
</div>
<a id="a053b1f857b70fdc5b36b325d585c8745" name="a053b1f857b70fdc5b36b325d585c8745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053b1f857b70fdc5b36b325d585c8745">&#9670;&#160;</a></span>get_identity_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> get_identity_matrix </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This fucntion gets a new matrix with the special attribute of being an identity matrix or multiplicative identity. That is, if you multiply any matrix or tuple by the identity matrix, you get back the matrix or tuple you started with. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns a new instance of an identity matrix. </dd></dl>

</div>
</div>
<a id="a6cc6a53ecf6c2f3f596d30db85181fb9" name="a6cc6a53ecf6c2f3f596d30db85181fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc6a53ecf6c2f3f596d30db85181fb9">&#9670;&#160;</a></span>get_minor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double get_minor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the minor of a given matrix. To put it differently, the minor of an element at row i and column j is the determinant of the submatrix at (i,j). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Receives the matrix from which the minor will be calculated. </td></tr>
    <tr><td class="paramname">row</td><td>Receives the row value from which the minor will be calculated. </td></tr>
    <tr><td class="paramname">col</td><td>Receives the column value from which the minor will be calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the minor of the matrix passed to the function as parameter. </dd></dl>

</div>
</div>
<a id="ab7df591ed1926b001ac7e2714b46a1db" name="ab7df591ed1926b001ac7e2714b46a1db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7df591ed1926b001ac7e2714b46a1db">&#9670;&#160;</a></span>get_submatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> get_submatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>del_row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>del_col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This functions gets the submatrix of a given matrix. That is, what is left when you delete a single row and column from a matrix. The submatrix of a 4x4 matrix is 3x3 and the submatrix of a 3x3 matrix is 2x2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Receives the matrix from which the submatrix will be calculated. </td></tr>
    <tr><td class="paramname">del_row</td><td>Receives a size_t value which stands for the row to be deleted when calculating the submatrix. </td></tr>
    <tr><td class="paramname">del_col</td><td>Receives a size_t value which stands for the column to be deleted when calculating the submatrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the submatrix of the matrix passed to the function as parameter. </dd></dl>

</div>
</div>
<a id="ad18f12a98d0aff3b1aba4a4b7c1a4a72" name="ad18f12a98d0aff3b1aba4a4b7c1a4a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18f12a98d0aff3b1aba4a4b7c1a4a72">&#9670;&#160;</a></span>inverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> inverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function get the inverse of a given matrix. That is, if you multiply some matrix <a class="el" href="class_a.html">A</a> by another matrix <a class="el" href="class_b.html">B</a>, producing <a class="el" href="class_c.html">C</a>, you can multiply <a class="el" href="class_c.html">C</a> by the inverse of <a class="el" href="class_b.html">B</a> to get <a class="el" href="class_a.html">A</a> again. To invert the matrix, this function employs a method known as cofactor expansion. Additionally, there some interesting properties of the inverse: 1) if you invert an identity matrix, the result is also an identity matrix. 2) when you multiply a matrix by its inverse, you get as result the identity matrix. 3) The inverse of the transpose of a matrix and the transpose of the inverse only commute if the matrix is symmetric or orthogonal. Otherwise, the result of the two operations will always be different. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Receives the matrix to be inverted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new matrix which is the inversion of the matrix passed to the function as parameter. </dd></dl>

</div>
</div>
<a id="aab9e09e616d4b4683ba17c892826a722" name="aab9e09e616d4b4683ba17c892826a722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab9e09e616d4b4683ba17c892826a722">&#9670;&#160;</a></span>is_invertible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">t_bool is_invertible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function checks if a given matrix is invertible or not. Not every matrix is invertible. An matrix is invertible if its determinant is a non-zero number. If its determinant is 0, then the given matrix is not invertible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Receives a matrix to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns TRUE if the given matrix is invertible. On the contrary, it returns FALSE if it's not invertible. </dd></dl>

</div>
</div>
<a id="a225ddd97ed6ed5ec894b3f555213790b" name="a225ddd97ed6ed5ec894b3f555213790b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a225ddd97ed6ed5ec894b3f555213790b">&#9670;&#160;</a></span>multiply_mx_mx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> multiply_mx_mx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function multiplies two matrices. "Mx" means matrix. For more information about how matrix multiplication works, refer to the book TRTC on page 28. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Receives the first matrix to be multiplied. </td></tr>
    <tr><td class="paramname">b</td><td>Receives the second matrix to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new matrix which is the product of the two matrices passed to the function as parameter. </dd></dl>

</div>
</div>
<a id="aff35de74d9504480cbdf50df468fcd4d" name="aff35de74d9504480cbdf50df468fcd4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff35de74d9504480cbdf50df468fcd4d">&#9670;&#160;</a></span>multiply_tp_mx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tuples_8h.html#a2169f9a7bb6d3ded00c7d8a718af65af">t_tuple</a> multiply_tp_mx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a></td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tuples_8h.html#a2169f9a7bb6d3ded00c7d8a718af65af">t_tuple</a></td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function multiplies a matrix by a tuple. "Mx" means matrix and "tp" means tuple. For more information about how vector and matrix multiplication works, refer to the following link quoted by author J. Buck: <a href="https://betterexplained.com/articles/linear-algebra-guide/">https://betterexplained.com/articles/linear-algebra-guide/</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Receives the matrix to be multiplied. </td></tr>
    <tr><td class="paramname">b</td><td>Receives the tuple to be multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new tuple which is the product of the two variables passed to the function as parameter. </dd></dl>

</div>
</div>
<a id="ab102c4ab11629464f6eec87eaa182825" name="ab102c4ab11629464f6eec87eaa182825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab102c4ab11629464f6eec87eaa182825">&#9670;&#160;</a></span>rotation_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> rotation_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tuples_8h.html#aea609bcc1e9134165bc86014c7974ec7">t_vector</a></td>          <td class="paramname"><span class="paramname"><em>vector</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the rotation matrix for a given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector</td><td>The vector for which the rotation matrix will be calculated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The rotation matrix for the given vector. </dd></dl>

</div>
</div>
<a id="aa58db7b9fdc1a5e8b4ad8db66f113738" name="aa58db7b9fdc1a5e8b4ad8db66f113738"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58db7b9fdc1a5e8b4ad8db66f113738">&#9670;&#160;</a></span>rotation_x()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> rotation_x </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rad</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function rotates a given matrix around the x-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rad</td><td>Receives the rotation around x axis to be performed in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new rotated matrix after the rotation passed to the function as parameter. </dd></dl>

</div>
</div>
<a id="a3184c113edb90be69bec3e2355b40a23" name="a3184c113edb90be69bec3e2355b40a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3184c113edb90be69bec3e2355b40a23">&#9670;&#160;</a></span>rotation_y()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> rotation_y </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rad</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function rotates a given matrix around the y-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rad</td><td>Receives the rotation around y axis to be performed in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new rotated matrix after the rotation passed to the function as parameter. </dd></dl>

</div>
</div>
<a id="a14c926cae7f2423369039f0711a2d717" name="a14c926cae7f2423369039f0711a2d717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c926cae7f2423369039f0711a2d717">&#9670;&#160;</a></span>rotation_z()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> rotation_z </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>rad</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function rotates a given matrix around the z-axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rad</td><td>Receives the rotation around z axis to be performed in radians. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new rotated matrix after the rotation passed to the function as parameter. </dd></dl>

</div>
</div>
<a id="a3448d79c382a6160f3bb09b901a114d1" name="a3448d79c382a6160f3bb09b901a114d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3448d79c382a6160f3bb09b901a114d1">&#9670;&#160;</a></span>scaling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> scaling </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function scales a given matrix by multiplication. When applied to an object centered at the origin, this transformation scales all points on the object, effectively making it larger (if the scale value is greater than 1) or smaller (if the scale value is less than 1). Note that reflection is scaling by a negative value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Receives the x-axis value to scale. </td></tr>
    <tr><td class="paramname">y</td><td>Receives the y-axis value to scale. </td></tr>
    <tr><td class="paramname">z</td><td>Receives the z-axis value to scale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new scaled matrix from the coordinates passed to the function as parameter. </dd></dl>

</div>
</div>
<a id="aab8a1e820c4bde5ca4973638bc86dcb7" name="aab8a1e820c4bde5ca4973638bc86dcb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8a1e820c4bde5ca4973638bc86dcb7">&#9670;&#160;</a></span>shearing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> shearing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a37d11cf3a94303cb0fdf026513e23087">t_shearing</a></td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a37d11cf3a94303cb0fdf026513e23087">t_shearing</a></td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a37d11cf3a94303cb0fdf026513e23087">t_shearing</a></td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function applies shearing (or skew) transformation to a given matrix. It has the effect of making straight lines slanted. Each coordinate is changed in proportion to the other two coordinates. When doing it to a matrix, it means that x will change in proportion to y and z, y will change in proportion to x and z and, lastly, z will change in proportion to x and y. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Receives a struct t_shearing storing the y and z values to change x in proportion to them. </td></tr>
    <tr><td class="paramname">y</td><td>Receives a struct t_shearing storing the x and z values to change y in proportion to them. </td></tr>
    <tr><td class="paramname">z</td><td>Receives a struct t_shearing storing the x and y values to change z in proportion to them. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new matrix after the shearing operation from values passed to the function as parameter. </dd></dl>

</div>
</div>
<a id="a66482775137fa71d5eaf2605358e33d7" name="a66482775137fa71d5eaf2605358e33d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66482775137fa71d5eaf2605358e33d7">&#9670;&#160;</a></span>translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> translation </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>z</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function translates a given matrix. Translation is a transformation that moves a point. Thus, it's important to note that the inverse of a translation matrix is another translation matrix that moves points in reverse. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Receives the x-axis value of the translation. </td></tr>
    <tr><td class="paramname">y</td><td>Receives the y-axis value of the translation. </td></tr>
    <tr><td class="paramname">z</td><td>Receives the z-axis value of the translation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new translated matrix from the coordinates passed to the function as parameter. </dd></dl>

</div>
</div>
<a id="a8d3c75778a90d4d4ef95cf08bd7c625d" name="a8d3c75778a90d4d4ef95cf08bd7c625d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3c75778a90d4d4ef95cf08bd7c625d">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a> transpose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab8f0736cc5d493e5ce876dd2550ab88a">t_matrix</a></td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function transposes the matrix passed to the function as parameter. In other words, it turns the first row into the first column, the second row into the second column, and so forth. Thus, it's importante to remember that the transpose of the identity matrix always gives the own identity matrix as result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>Receives the matrix to be transposed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a new matrix which is the transposition of the matrix passed to the function as parameter. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
